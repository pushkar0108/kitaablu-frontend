{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport getConfig from \"next/config\";\nimport { stringify } from \"query-string\"; // #endregion Global Imports\n// #region Interface Imports\n\n// #endregion Interface Imports\nconst {\n  publicRuntimeConfig: {\n    API_KEY,\n    API_URL\n  }\n} = getConfig();\nconst BaseUrl = `${API_URL}/api`;\nexport const Http = {\n  Request: async (methodType, url, params, payload) => {\n    return new Promise((resolve, reject) => {\n      const query = params ? `?${stringify(_objectSpread({}, params, {\n        api_key: API_KEY\n      }))}` : \"\";\n      fetch(`${BaseUrl}${url}${query}`, {\n        body: JSON.stringify(payload),\n        cache: \"no-cache\",\n        headers: {\n          \"content-type\": \"application/json\"\n        },\n        method: `${methodType}`\n      }).then(async response => {\n        if (response.status === 200) {\n          return response.json().then(resolve);\n        }\n\n        return reject(response);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n};","map":{"version":3,"sources":["/Users/pushkargoel/Myapps/next-boilerplate/src/Services/API/Http/index.ts"],"names":["getConfig","stringify","publicRuntimeConfig","API_KEY","API_URL","BaseUrl","Http","Request","methodType","url","params","payload","Promise","resolve","reject","query","api_key","fetch","body","JSON","cache","headers","method","then","response","status","json","catch","e"],"mappings":";;;;;;AAAA;AACA,OAAO,oBAAP;AACA,OAAOA,SAAP,MAAsB,aAAtB;AACA,SAASC,SAAT,QAA0B,cAA1B,C,CACA;AAEA;;AAEA;AAEA,MAAM;AACFC,EAAAA,mBAAmB,EAAE;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX;AADnB,IAEFJ,SAAS,EAFb;AAIA,MAAMK,OAAO,GAAI,GAAED,OAAQ,MAA3B;AAEA,OAAO,MAAME,IAAI,GAAG;AAChBC,EAAAA,OAAO,EAAE,OACLC,UADK,EAELC,GAFK,EAGLC,MAHK,EAILC,OAJK,KAKQ;AACb,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,YAAMC,KAAK,GAAGL,MAAM,GACb,IAAGT,SAAS,mBAAMS,MAAN;AAAcM,QAAAA,OAAO,EAAEb;AAAvB,SAAkC,EADjC,GAEd,EAFN;AAIAc,MAAAA,KAAK,CAAE,GAAEZ,OAAQ,GAAEI,GAAI,GAAEM,KAAM,EAA1B,EAA6B;AAC9BG,QAAAA,IAAI,EAAEC,IAAI,CAAClB,SAAL,CAAeU,OAAf,CADwB;AAE9BS,QAAAA,KAAK,EAAE,UAFuB;AAG9BC,QAAAA,OAAO,EAAE;AACL,0BAAgB;AADX,SAHqB;AAM9BC,QAAAA,MAAM,EAAG,GAAEd,UAAW;AANQ,OAA7B,CAAL,CAQKe,IARL,CAQU,MAAMC,QAAN,IAAkB;AACpB,YAAIA,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AACzB,iBAAOD,QAAQ,CAACE,IAAT,GAAgBH,IAAhB,CAAqBV,OAArB,CAAP;AACH;;AACD,eAAOC,MAAM,CAACU,QAAD,CAAb;AACH,OAbL,EAcKG,KAdL,CAcWC,CAAC,IAAI;AACRd,QAAAA,MAAM,CAACc,CAAD,CAAN;AACH,OAhBL;AAiBH,KAtBM,CAAP;AAuBH;AA9Be,CAAb","sourcesContent":["// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport getConfig from \"next/config\";\nimport { stringify } from \"query-string\";\n// #endregion Global Imports\n\n// #region Interface Imports\nimport { HttpModel } from \"@Interfaces\";\n// #endregion Interface Imports\n\nconst {\n    publicRuntimeConfig: { API_KEY, API_URL },\n} = getConfig();\n\nconst BaseUrl = `${API_URL}/api`;\n\nexport const Http = {\n    Request: async <A>(\n        methodType: string,\n        url: string,\n        params?: HttpModel.IRequestQueryPayload,\n        payload?: HttpModel.IRequestPayload\n    ): Promise<A> => {\n        return new Promise((resolve, reject) => {\n            const query = params\n                ? `?${stringify({ ...params, api_key: API_KEY })}`\n                : \"\";\n\n            fetch(`${BaseUrl}${url}${query}`, {\n                body: JSON.stringify(payload),\n                cache: \"no-cache\",\n                headers: {\n                    \"content-type\": \"application/json\",\n                },\n                method: `${methodType}`,\n            })\n                .then(async response => {\n                    if (response.status === 200) {\n                        return response.json().then(resolve);\n                    }\n                    return reject(response);\n                })\n                .catch(e => {\n                    reject(e);\n                });\n        });\n    },\n};\n"]},"metadata":{},"sourceType":"module"}